---
description: Full-stack development patterns for this React 19 + tRPC + TanStack Query monorepo. Use when creating new features, views, components, or server logic.
globs:
  ["apps/**/*.ts", "apps/**/*.tsx", "packages/**/*.ts", "packages/**/*.tsx"]
---

# Project Development Guide

This monorepo uses React 19, tRPC v11, TanStack Query v5, and a feature-based architecture. Follow these patterns when adding new functionality.

## Monorepo Structure

```
apps/
├── api/                    # Express + tRPC backend
│   └── src/
│       ├── features/       # Feature-specific routers & services
│       ├── trpc/           # tRPC initialization & root router
│       └── index.ts        # Express server entry
├── web/                    # React 19 + Vite frontend
│   └── src/
│       ├── features/       # Feature-specific components & utils
│       ├── shared/         # Shared components across features
│       └── lib/            # tRPC client setup
packages/
├── types/                  # Shared types with Zod schemas
├── ui/                     # shadcn/ui component library
└── eslint-config/          # Shared ESLint configuration
```

## Creating a New Feature

### Step 1: Define Types in `packages/types`

Create Zod schemas and infer types for type-safe validation:

```typescript
// packages/types/src/[feature]/[entity].type.ts
import { z } from "zod";

export const playlistSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string(),
  videoCount: z.number(),
});

export type Playlist = z.infer<typeof playlistSchema>;
```

Export from domain index:

```typescript
// packages/types/src/[feature]/index.ts
export * from "./playlist.type";
```

Export from package root:

```typescript
// packages/types/src/index.ts
export * from "./[feature]";
```

### Step 2: Create Backend Service

Services contain business logic and external API calls:

```typescript
// apps/api/src/features/[feature]/[feature].service.ts
import type { Playlist } from "@repo/types";

/**
 * Fetch playlists for a channel
 */
export const fetchPlaylists = async (
  channelId: string
): Promise<Playlist[]> => {
  const apiKey = process.env.YOUTUBE_API_KEY;

  if (!apiKey) {
    throw new Error("YouTube API key not configured on server");
  }

  // Implementation...
  return playlists;
};
```

### Step 3: Create tRPC Router

Routers expose type-safe procedures using Zod validation:

```typescript
// apps/api/src/features/[feature]/[feature].router.ts
import { z } from "zod";
import { router, publicProcedure } from "../../trpc/init";
import { fetchPlaylists } from "./[feature].service";

export const playlistRouter = router({
  /**
   * Get playlists for a channel
   */
  getPlaylists: publicProcedure
    .input(z.object({ channelId: z.string().min(1) }))
    .query(async ({ input }) => {
      const playlists = await fetchPlaylists(input.channelId);
      return { playlists };
    }),

  /**
   * Create a new playlist (mutation example)
   */
  createPlaylist: publicProcedure
    .input(
      z.object({
        title: z.string().min(1),
        description: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      // Implementation...
      return { success: true };
    }),
});
```

### Step 4: Register Router in App Router

```typescript
// apps/api/src/trpc/router.ts
import { router } from "./init";
import { youtubeRouter } from "../features/youtube/youtube.router";
import { playlistRouter } from "../features/playlist/playlist.router";

export const appRouter = router({
  youtube: youtubeRouter,
  playlist: playlistRouter,
});

export type AppRouter = typeof appRouter;
```

### Step 5: Create Frontend Components

#### Container Component (with data fetching)

Use `useTRPC` hook for TanStack Query integration:

```typescript
// apps/web/src/features/[feature]/components/[feature]-list.component.tsx
import React from "react";
import { useTRPC } from "@/lib/trpc";
import { useQuery } from "@tanstack/react-query";
import type { Playlist } from "@repo/types";
import { Card, Skeleton } from "@repo/ui";

type PlaylistListProps = {
  channelId: string;
};

/**
 * Playlist list container component
 * Fetches and displays playlists for a channel
 */
export const PlaylistList: React.FC<PlaylistListProps> = ({ channelId }) => {
  const trpc = useTRPC();

  const { data, isLoading, error } = useQuery(
    trpc.playlist.getPlaylists.queryOptions({ channelId })
  );

  if (isLoading) {
    return <Skeleton className="h-48" />;
  }

  if (error) {
    return <p className="text-destructive">{error.message}</p>;
  }

  return (
    <div className="grid gap-4">
      {data?.playlists.map((playlist) => (
        <PlaylistCard key={playlist.id} playlist={playlist} />
      ))}
    </div>
  );
};
```

#### Presentational Component (UI only)

```typescript
// apps/web/src/features/[feature]/components/[feature]-card.component.tsx
import React from "react";
import type { Playlist } from "@repo/types";
import { Card, CardContent, CardHeader, CardTitle } from "@repo/ui";

type PlaylistCardProps = {
  playlist: Playlist;
  onClick?: (playlist: Playlist) => void;
};

/**
 * Playlist card presentational component
 */
export const PlaylistCard: React.FC<PlaylistCardProps> = ({
  playlist,
  onClick
}) => {
  return (
    <Card
      onClick={() => onClick?.(playlist)}
      className="cursor-pointer hover:shadow-md transition-shadow"
    >
      <CardHeader>
        <CardTitle>{playlist.title}</CardTitle>
      </CardHeader>
      <CardContent>
        <p className="text-muted-foreground">{playlist.description}</p>
        <p className="text-sm mt-2">{playlist.videoCount} videos</p>
      </CardContent>
    </Card>
  );
};
```

#### Utility Functions (imperative tRPC calls)

For event handlers or non-hook contexts, use the vanilla client:

```typescript
// apps/web/src/features/[feature]/utils/[feature].utils.ts
import { trpcClient } from "@/lib/trpc";
import type { Playlist } from "@repo/types";

/**
 * Fetch playlists imperatively
 * Use in event handlers or outside React components
 */
export const fetchPlaylists = async (
  channelId: string
): Promise<Playlist[]> => {
  const { playlists } = await trpcClient.playlist.getPlaylists.query({
    channelId,
  });
  return playlists;
};

/**
 * Create playlist imperatively
 */
export const createPlaylist = async (title: string, description?: string) => {
  return await trpcClient.playlist.createPlaylist.mutate({
    title,
    description,
  });
};
```

## tRPC Client Patterns

### Using React Hooks (TanStack Query)

```typescript
import { useTRPC } from "@/lib/trpc";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";

// Query with options
const trpc = useTRPC();
const { data, isLoading } = useQuery(
  trpc.youtube.getVideos.queryOptions({ channelId })
);

// Mutation with cache invalidation
const queryClient = useQueryClient();
const mutation = useMutation(
  trpc.ai.analyze.mutationOptions({
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["analysis"] });
    },
  })
);
```

### Using Vanilla Client (Imperative)

```typescript
import { trpcClient } from "@/lib/trpc";

// Query call
const { videos } = await trpcClient.youtube.getVideos.query({ channelId });

// Mutation call
const result = await trpcClient.ai.analyze.mutate({ video, comments });
```

## UI Component Patterns

Import from `@repo/ui` for consistent styling:

```typescript
import {
  Button,
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  Input,
  Label,
  Skeleton,
  cn, // className utility
} from "@repo/ui";
```

Use `cn()` for conditional class merging:

```typescript
<div className={cn(
  "base-class",
  isActive && "active-class",
  variant === "primary" ? "primary-styles" : "secondary-styles"
)}>
```

## File Naming Conventions

| Type       | Pattern                | Example                    |
| ---------- | ---------------------- | -------------------------- |
| Components | `[name].component.tsx` | `video-card.component.tsx` |
| Services   | `[name].service.ts`    | `youtube.service.ts`       |
| Routers    | `[name].router.ts`     | `youtube.router.ts`        |
| Types      | `[name].type.ts`       | `youtube-video.type.ts`    |
| Utilities  | `[name].utils.ts`      | `youtube.utils.ts`         |
| Hooks      | `use-[name].hook.ts`   | `use-video-player.hook.ts` |

## Adding a New View/Page

For multi-page apps, create view components in the feature:

```typescript
// apps/web/src/features/[feature]/views/[feature].view.tsx
import React from "react";
import { PlaylistList } from "../components/playlist-list.component";
import { Header } from "@/shared/components/header.component";

/**
 * Playlist feature main view
 */
export const PlaylistView: React.FC = () => {
  return (
    <div className="min-h-screen bg-background">
      <Header />
      <main className="container mx-auto px-4 py-8 max-w-6xl">
        <h1 className="text-2xl font-bold mb-6">Playlists</h1>
        <PlaylistList channelId="..." />
      </main>
    </div>
  );
};
```

## Error Handling

### Backend (Services)

Throw descriptive errors that tRPC will serialize:

```typescript
if (!apiKey) {
  throw new Error("API key not configured on server");
}

if (!response.ok) {
  throw new Error(data.error?.message || "Request failed");
}
```

### Frontend (Components)

Handle loading and error states explicitly:

```typescript
const { data, isLoading, error } = useQuery(
  trpc.youtube.getVideos.queryOptions({ channelId })
);

if (isLoading) return <Skeleton />;
if (error) return <ErrorMessage error={error.message} />;
return <VideoGrid videos={data.videos} />;
```

## Environment Variables

Backend variables in `apps/api/.env`:

```
YOUTUBE_API_KEY=...
GEMINI_API_KEY=...
PORT=3001
```

Access via `process.env.VARIABLE_NAME` in services.

## References

@apps/api/src/trpc/init.ts
@apps/api/src/trpc/router.ts
@apps/api/src/features/youtube/youtube.router.ts
@apps/api/src/features/youtube/youtube.service.ts
@apps/web/src/lib/trpc.ts
@apps/web/src/features/youtube/components/video-card.component.tsx
@apps/web/src/features/youtube/utils/youtube.utils.ts
@packages/types/src/youtube/youtube-video.type.ts
@packages/ui/src/index.ts
